<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>三喵notes</title>
    
    
<link rel="stylesheet" href="/diary/css/style.css">

    
<link rel="stylesheet" href="/diary/css/gitment.css">


<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="/diary/" class="header-nav-link" >
                首页
            </a>
            

            
            <a href="/diary/archives" class="header-nav-link">
                归档
            </a>
            

            
            <a href="/diary/tags" class="header-nav-link">
                标签
            </a>
            

            
            <a href="/diary/about/" class="header-nav-link">
                关于
            </a>
            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="/diary/" class="mobile-nav-title-link">三喵's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="/diary/" class="mobile-nav-link">首页</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="/diary/archives" class="mobile-nav-link">归档</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="/diary/tags" class="mobile-nav-link">标签</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/diary/about/" class="mobile-nav-link">关于</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    <article class="post-whole">
        <div class="post-title">
            <h2 class="title">从0到1搭建一套CI/CD流程</h2>
            <div class="post-meta">
                <span class="post-time">2022-03-02</span>
                
                <span class="post-category">
                    
                    <a class="category" href="/diary/categories/%E5%BB%BA%E7%AB%99/">建站</a>
                    
                </span>
                
                <span class="post-visit"> 阅读次数：<span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
        <div class="post-toc" id="post-toc">
    <strong class="post-toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88"><span class="toc-text">服务器配置方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E6%9C%BA%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-text">构建机的软件安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">docker的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jenkis%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">jenkis的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nexus%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">Nexus的安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Harbor%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-text">Harbor的安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K8S%E6%9C%BA%E5%99%A8%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85"><span class="toc-text">K8S机器的软件安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85"><span class="toc-text">基础安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85"><span class="toc-text">主节点安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85"><span class="toc-text">子节点安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8"><span class="toc-text">部署应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%8A%82%E7%82%B9%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E6%96%87%E4%BB%B6"><span class="toc-text">主节点配置部署文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ingress%E5%AE%89%E8%A3%85"><span class="toc-text">ingress安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kubesphere%E5%AE%89%E8%A3%85"><span class="toc-text">kubesphere安装</span></a></li></ol></li></ol>
    <div class="back-to-top" id="back-to-top">
        <a href="javascript:void(0);">回到顶部</a>
    </div>
</div>
        <div class="post-content">
            <p>以往的的构建部署流程为编写代码、上传代码库、编译压缩为制品、上传到服务器启动。这套流程不仅繁琐，且容易出错，是非常影响开发效率的。为了高效的构建和部署，我们就需要学习<strong>CI/CD</strong>了。</p>
<p><code>CI</code> 的意思是 <code>持续构建</code> 。负责拉取代码库中的代码后，执行用户预置定义好的操作脚本，通过一系列编译操作构建出一个 <code>制品</code> ，并将制品推送至到制品库里面。常用工具有 Gitlab CI，Github CI，Jenkins 等。这个环节不参与部署，只负责构建代码，然后保存构建物。构建物被称为 制品，保存制品的地方被称为 <strong>制品库</strong>。</p>
<p>CD 则有2层含义： <code>持续部署（Continuous Deployment）</code> 和 <code>持续交付（Continuous Delivery）</code> 。 <code>持续交付</code> 的概念是：将制品库的制品拿出后，部署在测试环境 / 交付给客户提前测试。 <code>持续部署</code> 则是将制品部署在生产环境。可以进行持续部署的工具也有很多： <code>Ansible</code> 批量部署， <code>Docker</code> 直接推拉镜像等等。当然也包括我们后面要写到的 <code>Kubernetes</code> 集群部署。</p>
<span id="more"></span>



<h2 id="服务器配置方案"><a href="#服务器配置方案" class="headerlink" title="服务器配置方案"></a>服务器配置方案</h2><p>本次教程记录使用的服务器为购买的二手Dell R720服务器，按照以下表格创建五个虚拟机，每个虚拟机安装的系统都为<strong>Centos7</strong>，<a href="https://link.juejin.cn/?target=https://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-Minimal-2009.iso">下载地址</a>。大家如果使用云服务器，按照同样的配置购买即可。</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>技术栈</th>
<th>类型</th>
<th>标签</th>
</tr>
</thead>
<tbody><tr>
<td>8核16G</td>
<td>Jenkins + Nexus + Docker</td>
<td>虚拟机</td>
<td>构建机</td>
</tr>
<tr>
<td>8核16G</td>
<td>Kibana</td>
<td>虚拟机</td>
<td>日志收集</td>
</tr>
<tr>
<td>8核16G</td>
<td>Docker + Kubernetes</td>
<td>虚拟机</td>
<td>Kubernetes Master</td>
</tr>
<tr>
<td>4核8G</td>
<td>Docker + Kubernetes</td>
<td>虚拟机</td>
<td>Kubernetes Node</td>
</tr>
<tr>
<td>4核8G</td>
<td>Docker + Kubernetes</td>
<td>虚拟机</td>
<td>Kubernetes Node</td>
</tr>
</tbody></table>
<h2 id="构建机的软件安装"><a href="#构建机的软件安装" class="headerlink" title="构建机的软件安装"></a>构建机的软件安装</h2><p>本台机器我们安装三个软件，Docker - 服务载体，Jenkins - 构建工具，Nexus - 制品仓库或者harbor - 制品仓库。</p>
<h3 id="docker的安装"><a href="#docker的安装" class="headerlink" title="docker的安装"></a>docker的安装</h3><p>docker贯穿CI/CD中整个流程，作为应用服务的载体有着非常重要的地位。我们可以使用docker将应用打包成一个镜像，交给kubernetes去部署在目标服务集群。并且可以将镜像上传到自己的镜像仓库，做好版本分类处理。</p>
<p>安装方式：添加docker的镜像源，可以加速docker的安装，然后进行yum安装。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 安装yum扩展包，安装后可以使用yum-config-manager来方便的添加源</span><br><span class="line">yum install yum-utils</span><br><span class="line"></span><br><span class="line"># 增加镜像源</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 安装docker</span><br><span class="line">yum install docker-ce</span><br><span class="line"></span><br><span class="line"># 查看安装版本</span><br><span class="line">$ docker -v</span><br><span class="line">Docker version 20.10.12, build e91ed57</span><br></pre></td></tr></table></figure>

<p>镜像加速器的配置，拉取官方的镜像库的镜像，会比较慢，我们改用国内阿里的镜像库。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo cd /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://llu06o1m.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>我们在次安装辅助工具<strong>docker-compose</strong>，compose是一个用来定义和运行复杂应用的Docker工具。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 安装命令</span><br><span class="line">yum install docker-compose</span><br></pre></td></tr></table></figure>



<h3 id="jenkis的安装"><a href="#jenkis的安装" class="headerlink" title="jenkis的安装"></a>jenkis的安装</h3><p>首先需要安装git，在ci流程中构建机需要去拉取代码，所以必须得安装git。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 安装命令</span><br><span class="line">yum install -y git</span><br><span class="line"></span><br><span class="line"># 查看安装版本</span><br><span class="line">$ git --version</span><br><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure>

<p>因为Jenkins是Java编写的持续构建平台，所以安装Java必不可少。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装命令</span><br><span class="line">yum install -y java</span><br><span class="line"></span><br><span class="line"># 查看安装版本</span><br><span class="line">$ java -version</span><br><span class="line">openjdk version &quot;1.8.0_322&quot;</span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_322-b06)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.322-b06, mixed mode)</span><br></pre></td></tr></table></figure>

<p>由于yum源不自带jenkins的安装源，于是我们需要自己导入一份jenkins安装源进行安装。导入后，使用yum命令安装即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 下载源文件</span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line"># 导入软件源</span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br><span class="line"># 安装jenkins</span><br><span class="line">yum install jenkins</span><br></pre></td></tr></table></figure>

<blockquote><p>rpm适用于所有环境，而yum要有本地yum源才可以使用。yum是上层管理工具，可以自动解决依赖性，而rpm是底层管理工具。</p>
<p>yum是基于rpm包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p>
</blockquote> 

<p>jenkins安装成功后，会将启动命令注册到系统systemd命令中。我们可以直接通过systemctl操作jenkins。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 启动</span><br><span class="line">systemctl start jenkins</span><br><span class="line"># 重启</span><br><span class="line">systemctl restart jenkins</span><br><span class="line"># 停止</span><br><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure>

<p>在启动前，先进行防火墙设置，放开8080端口的访问。因为jenkins启动默认的端口为8080，需要修改在**/etc/sysconfig/jenkins<strong>配置文件中的</strong>JENKINS_PORT**，我们这里使用默认的8080。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 添加开放端口</span><br><span class="line">firewall-cmd --permanent --add-port=8080/tcp</span><br><span class="line"># 重新加载配置</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"># 查看开放端口列表</span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure>

<p>启动完成后，我们使用<strong>IP:8080</strong>来进行访问，我们可以看到解锁jenkins界面，执行下面的命令，获取密码，输入密码后确定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>

<p>下一步我们需要安装插件，我们选推荐的插件，后续需要其他插件再去安装，安装完插件，注册个账号即完成了安装。</p>
<p>我们要使用jenkins操作docker，需要进行权限设定，否则用不了。docker提供了一个用户组的概念。我们可以将执行Shell的用户添加到名称为docker的用户组，则可以正常执行docker命令。设置好后我们重启jenkins，就可以试试创建流水线脚本使用docker。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 将当前用户添加至docker用户组</span><br><span class="line">gpasswd -a jenkins docker</span><br><span class="line"></span><br><span class="line"># 更新docker用户组</span><br><span class="line">newgrp docker</span><br><span class="line"></span><br><span class="line"># 重启jenkins</span><br><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure>

<h3 id="Nexus的安装"><a href="#Nexus的安装" class="headerlink" title="Nexus的安装"></a>Nexus的安装</h3><p>镜像库就是集中存放镜像的一个文件服务。镜像库在CI/CD中，又称制品库。构建后的产物称为制品，制品则要放到制品库做中转和版本管理。常用平台有Nexus，Jfrog，Harbor或其他对象存储平台。</p>
<p>在这里，我们选用Nexus3作为自己的镜像库。因为其稳定，性能好，免费，部署方便，且支持类型多，是许多制品库的首选选型。</p>
<p>下载nexus并解压安装包，解压后，我们可以看到有2个文件夹。分别是nexus-3.29.0-02和sonatype-work。其中，nexus-3.29.0-02是nexus主程序文件夹，sonatype-work则是数据文件。由于nexus默认服务端口是8081，稍后我们还需要给镜像库访问单独开放一个8082端口。这里将8081，8082端口添加到防火墙放行规则内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 下载安装包</span><br><span class="line">wget https://dependency-fe.oss-cn-beijing.aliyuncs.com/nexus-3.29.0-02-unix.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压安装包</span><br><span class="line">tar -xzvf nexus-3.29.0-02-unix.tar.gz</span><br><span class="line"></span><br><span class="line"># 开放端口</span><br><span class="line">firewall-cmd --permanent --add-port=8081/tcp</span><br><span class="line">firewall-cmd --permanent --add-port=8082/tcp</span><br><span class="line"></span><br><span class="line"># 重新加载防火墙</span><br><span class="line">systemctl reload firewalld</span><br></pre></td></tr></table></figure>

<p>我们查看下nexus的bin目录下的内容，nexus为执行程序，对应了启动停止等命令，我们启动nexus：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 可使用命令</span><br><span class="line">Usage: ./nexus &#123;start|stop|run|run-redirect|status|restart|force-reload&#125;</span><br></pre></td></tr></table></figure>

<p>访问<strong>ip:8081</strong>打开管理后台，点击右上角<strong>sign up</strong>准备获取密码。拿到密码后输入admin账号，和获取到的密码登录进去，然后在引导下重置新密码。修改后，我们需要设置<strong>Configure Anonymous Access</strong>的值。这一步的意思是是否开启匿名访问。匿名访问是指：<strong>我们在没有登录的情况下，拉取（推送）制品到制品库，都算匿名访问。</strong>这是个很便捷，也是个危险的行为。为了安全，我们禁用disable。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 获取管理员密码</span><br><span class="line">cat /root/sonatype-work/nexus3/admin.password</span><br></pre></td></tr></table></figure>

<p>接下来，我们点击左上角齿轮，选择Repository，点击Create Repository，这里我们选用docker（hosted）填入仓库名称和填入前面我们预留的8082端口号到HTTP输入框，点击保存。</p>
<blockquote><p>在 nexus 中，制品库一般分为以下三种类型：</p>
<p>proxy: 此类型制品库原则上只下载，不允许用户推送。可以理解为缓存外网制品的制品库。例如，我们在拉取 nginx 镜像时，如果通过 proxy 类型的制品库，则它会去创建时配置好的外网 docker 镜像源拉取（有点像 cnpm ）到自己的制品库，然后给你。第二次拉取，则不会从外网下载。起到 内网缓存 的作用。<br>hosted：此类型制品库和 proxy 相反，原则上 只允许用户推送，不允许缓存。这里只存放自己的私有镜像或制品。<br>group：此类型制品库可以将以上两种类型的制品库组合起来。组合后只访问 group 类型制品库，就都可以访问。</p>
</blockquote>

<p>接下来给镜像库添加访问权限，点击左边菜单的<strong>Realms</strong>，然后在页面的穿梭框中，把左边的Docker Bearer Token Realm，将其添加到右边的Active内，保存即可。下面我们试下登录制品库，首先修改docker的私有镜像仓库配置，在配置文件中增加如下信息，然后进行登录测试，如果你的制品库安装在其他的服务器，ip换成对应的外网ip，局域网的话换成局域网ip，登录的账号密码为nexus账号密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://llu06o1m.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;127.0.0.1:8082&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker login 127.0.0.1:8082</span><br><span class="line">Username: admin</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>

<p>为了安全，我们可以把nexus的账号密码配置到jenkins的凭证中，在jenkinsfile的脚本中就可以使用变量来用。接下来修改代码中的Jenkinsfile，然后在次去任务中build now构建。</p>
<h3 id="Harbor的安装"><a href="#Harbor的安装" class="headerlink" title="Harbor的安装"></a>Harbor的安装</h3><p>在家目录我们创建harbor目录，用在存放harbor程序。程序<a target="_blank" rel="noopener" href="https://github.com/goharbor/harbor/releases">下载地址</a>，我们下载v1.10.10的在线版，右键复制下载链接，进入家目录，执行下面的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载文件</span><br><span class="line">wget https://github.com/goharbor/harbor/releases/download/v1.10.10/harbor-online-installer-v1.10.10.tgz</span><br><span class="line"># 解压文件</span><br><span class="line">tar -xzvf harbor-online-installer-v1.10.10.tgz</span><br></pre></td></tr></table></figure>

<p>进行harbor目录，修改harbor.yml配置文件，修改http端口为8083，修改管理后台密码 和 镜像库密码，修改hostname，注释掉https。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hostname: 192.168.31.65</span><br><span class="line">http:</span><br><span class="line">  port: 8083</span><br><span class="line">harbor_admin_password: 921110</span><br><span class="line">database:</span><br><span class="line">  password: 921110</span><br><span class="line"># https:</span><br><span class="line">  # port: 443</span><br><span class="line">  # certificate: /your/certificate/path</span><br><span class="line">  # private_key: /your/private/key/path</span><br></pre></td></tr></table></figure>

<p>然后进行install安装，执行下面的命令，安装完成后，我们可以通过docker images查看创建的镜像和通过docker ps看正在运行的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 安装程序</span><br><span class="line">sh ./install.sh</span><br><span class="line"># 查看镜像</span><br><span class="line">docker images</span><br><span class="line">goharbor/chartmuseum-photon           v1.10.10   b8add6b726bb   7 weeks ago    169MB</span><br><span class="line">goharbor/redis-photon                 v1.10.10   da80bdfe2937   7 weeks ago    149MB</span><br><span class="line">goharbor/clair-adapter-photon         v1.10.10   914f98d8a471   7 weeks ago    67.3MB</span><br><span class="line">goharbor/clair-photon                 v1.10.10   ec877cd064a9   7 weeks ago    178MB</span><br><span class="line">goharbor/notary-server-photon         v1.10.10   90981e58f79f   7 weeks ago    105MB</span><br><span class="line">goharbor/notary-signer-photon         v1.10.10   e50ee961a9d6   7 weeks ago    102MB</span><br><span class="line">goharbor/harbor-registryctl           v1.10.10   8cff0f50ad4a   7 weeks ago    97.3MB</span><br><span class="line">goharbor/registry-photon              v1.10.10   465538cf61bc   7 weeks ago    81.8MB</span><br><span class="line">goharbor/nginx-photon                 v1.10.10   86473ef9ef24   7 weeks ago    44.9MB</span><br><span class="line">goharbor/harbor-log                   v1.10.10   c9cb00a7af3e   7 weeks ago    108MB</span><br><span class="line">goharbor/harbor-jobservice            v1.10.10   d244473b6165   7 weeks ago    88.8MB</span><br><span class="line">goharbor/harbor-core                  v1.10.10   b3be36cace3a   7 weeks ago    81.5MB</span><br><span class="line">goharbor/harbor-portal                v1.10.10   1980673cc854   7 weeks ago    53MB</span><br><span class="line">goharbor/harbor-db                    v1.10.10   0c6ce792483e   7 weeks ago    187MB</span><br><span class="line">goharbor/prepare                      v1.10.10   475fb37cdd49   7 weeks ago    200MB</span><br><span class="line"># 查看容器</span><br><span class="line">0d3c29ced59a   goharbor/nginx-photon:v1.10.10         &quot;nginx -g &#x27;daemon of…&quot;   5 minutes ago   Up 5 minutes (healthy)   0.0.0.0:8083-&gt;8080/tcp, :::8083-&gt;8080/tcp   nginx</span><br><span class="line">e63a4dc602bb   goharbor/harbor-jobservice:v1.10.10    &quot;/harbor/harbor_jobs…&quot;   5 minutes ago   Up 5 minutes (healthy)                                               harbor-jobservice</span><br><span class="line">de3511bff6a0   goharbor/harbor-core:v1.10.10          &quot;/harbor/harbor_core&quot;    5 minutes ago   Up 5 minutes (healthy)                                               harbor-core</span><br><span class="line">2ffb579e8d07   goharbor/registry-photon:v1.10.10      &quot;/home/harbor/entryp…&quot;   5 minutes ago   Up 5 minutes (healthy)   5000/tcp                                    registry</span><br><span class="line">baf8c9194de3   goharbor/harbor-portal:v1.10.10        &quot;nginx -g &#x27;daemon of…&quot;   5 minutes ago   Up 5 minutes (healthy)   8080/tcp                                    harbor-portal</span><br><span class="line">412e3a09707d   goharbor/harbor-registryctl:v1.10.10   &quot;/home/harbor/start.…&quot;   5 minutes ago   Up 5 minutes (healthy)                                               registryctl</span><br><span class="line">427b88ffbd3c   goharbor/harbor-db:v1.10.10            &quot;/docker-entrypoint.…&quot;   5 minutes ago   Up 5 minutes (healthy)   5432/tcp                                    harbor-db</span><br><span class="line">cfbb8e1b4380   goharbor/redis-photon:v1.10.10         &quot;redis-server /etc/r…&quot;   5 minutes ago   Up 5 minutes (healthy)   6379/tcp                                    redis</span><br><span class="line">216f83ed2415   goharbor/harbor-log:v1.10.10           &quot;/bin/sh -c /usr/loc…&quot;   5 minutes ago   Up 5 minutes (healthy)   127.0.0.1:1514-&gt;10514/tcp                   harbor-log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>记得需要修改docker的配置，加上刚才新设定的8083端口，不然docker login会失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://llu06o1m.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.31.65:8082&quot;, &quot;192.168.31.65:8083&quot;] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在输入<strong>ip:8083</strong>可以进入harbor管理后台，输入admin账号和刚才更改的密码。然后我们可以创建项目，修改Jenkinsfile来向项目仓库推送镜像了。</p>
<blockquote><p>个人倾向于使用harbor，界面简单且支持中文，我们公司也使用的harbor。</p>
</blockquote>



<h2 id="K8S机器的软件安装"><a href="#K8S机器的软件安装" class="headerlink" title="K8S机器的软件安装"></a>K8S机器的软件安装</h2><p>在Kubernetes中，可以使用集群来组织服务器的。集群中会存在一个Master节点，该节点是Kubernetes集群的控制节点，负责调度集群中其他服务器的资源。其他节点被称为Node，Node可以是物理机也可以是虚拟机。</p>
<h3 id="基础安装"><a href="#基础安装" class="headerlink" title="基础安装"></a>基础安装</h3><p>以下内容1个master节点和2个node节点都需要安装。</p>
<p>先安装三个软件：vim是Linux下的一个文件编辑器；wget可以用作文件下载使用；ntpdate则是可以用来同步时区。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install vim wget ntpdate -y</span><br></pre></td></tr></table></figure>

<p>接着使用 <code>ntpdate</code> 来统一我们的系统时间和时区，服务器时间与阿里云服务器对齐。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 统一时区，为上海时区</span><br><span class="line">ln -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">bash -c &quot;echo &#x27;Asia/Shanghai&#x27; &gt; /etc/timezone&quot;</span><br><span class="line"></span><br><span class="line"># 统一使用阿里服务器进行时间更新</span><br><span class="line">ntpdate ntp1.aliyun.com</span><br></pre></td></tr></table></figure>

<p>接着我们关闭防火墙。因为kubernetes会创建防火墙规则，导致防火墙规则重复。所以这里我们要将防火墙关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld &amp; systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<p>这一步需要我们关闭Swap分区。Swap是Linux的交换分区，在系统资源不足时，Swap分区会启用。这操作会拖慢我们的应用性能。应该让新创建的服务自动调度到集群的其他Node节点中去，而不是使用Swap分区。这里我们将它关闭掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 临时关闭</span><br><span class="line">swapoff -a</span><br><span class="line"># 永久关闭，注释掉下面这一行：</span><br><span class="line">vi /etc/fstab</span><br><span class="line">/dev/mapper/centos-swap swap ...</span><br></pre></td></tr></table></figure>

<p>继续关闭Selinux。这是为了支持容器可以访问宿主机文件系统所做的，后续也许会优化掉：</p>
<blockquote>
<p>Selinux为Linux内核子系统引入了一个健壮的强制控制访问Mandatory Access Control架构</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 暂时关闭 selinux</span><br><span class="line">setenforce 0</span><br><span class="line"></span><br><span class="line"># 永久关闭</span><br><span class="line">vi /etc/sysconfig/selinux</span><br><span class="line"># 修改以下参数，设置为disable</span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<p>继续安装docker，按照上次安装的步骤安装即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 安装yum扩展包，安装后可以使用yum-config-manager来方便的添加源</span><br><span class="line">yum install yum-utils</span><br><span class="line"># 增加镜像源</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"># 安装docker</span><br><span class="line">yum install docker-ce</span><br><span class="line"># 查看安装版本</span><br><span class="line">docker -v</span><br><span class="line">Docker version 20.10.12, build e91ed57</span><br><span class="line"># 修改配置源 insecure-registries 修改为自己的节点</span><br><span class="line">sudo cd /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;insecure-registries&quot;: [&quot;192.168.31.65:6000&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://llu06o1m.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>接下来安装Kubernetes组件，首先先将安装源更换为为国内的阿里云源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p>接着直接使用yum命令安装kubelet、kubeadm、kubectl即可，安装完毕后启用kubelet即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装三个软件</span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line"># 启动kubelet</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Kubelet负责与其他节点集群通信，并进行本节点Pod和容器生命周期的管理，是Kubernetes中的核心组件。它会运行在集群的所有节点上，并负责创建启动服务容器。</p>
</li>
<li><p>Kubeadm是Kubernetes的自动化部署工具，降低了部署难度，提高效率，用来初始化集群，子节点加入的工具。</p>
</li>
<li><p>Kubectl是Kubernetes集群管理工具，可以用来管理，删除，创建资源 。</p>
</li>
</ul>
<h3 id="主节点安装"><a href="#主节点安装" class="headerlink" title="主节点安装"></a>主节点安装</h3><p>hostnamectl是Centos7出的新命令，可以用来修改主机名称：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname  k8s-master</span><br></pre></td></tr></table></figure>

<p>接着我们使用kubeadm config print init-defaults输出一份默认初始化配置文件，使用&gt;操作符即可导出为一份文件，方便我们进行修改。</p>
<p>主要对配置文件做这几件事情：</p>
<ul>
<li>更换 <code>Kubernetes</code> 镜像仓库为阿里云镜像仓库，加速组件拉取</li>
<li>替换 <code>ip</code> 为自己主机 <code>ip</code> </li>
<li>配置 <code>pod</code> 网络为 <code>flannel</code> 网段</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 导出配置</span><br><span class="line">kubeadm config print init-defaults &gt; init-kubeadm.conf</span><br><span class="line"># 编辑配置</span><br><span class="line">vim init-kubeadm.conf</span><br><span class="line"></span><br><span class="line"># 以下为完整配置</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 1.2.3.4</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: /var/run/dockershim.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: node</span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: k8s.gcr.io</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.23.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>修改部分配置信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># imageRepository: k8s.gcr.io 更换k8s镜像仓库</span><br><span class="line">imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line"># localAPIEndpointc，advertiseAddress为master-ip ，port默认不修改</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.56.101  # 此处为master的IP</span><br><span class="line">  bindPort: 6443</span><br><span class="line"># 配置子网络</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">  podSubnet: 10.244.0.0/16	# 添加这个</span><br></pre></td></tr></table></figure>

<p>在修改完配置文件后，我们需要使用kubeadm拉取我们的默认组件镜像。直接使用kubeadm config images pull命令即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 进行镜像拉取</span><br><span class="line">kubeadm config images pull --config init-kubeadm.conf</span><br><span class="line"># 以下为拉取到的组件镜像</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver            v1.23.0   e6bf5ddd4098   2 months ago   135MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-controller-manager   v1.23.0   37c6aeb3663b   2 months ago   125MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-scheduler            v1.23.0   56c5af1d00b5   2 months ago   53.5MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/kube-proxy                v1.23.0   e03484a90585   2 months ago   112MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/etcd                      3.5.1-0   25f8c7f3da61   4 months ago   293MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/coredns                   v1.8.6    a4ca41631cc7   5 months ago   46.8MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/google_containers/pause                     3.6       6270bb605e12   6 months ago   683kB</span><br></pre></td></tr></table></figure>

<p>在镜像拉取后，我们就可以使用刚才编辑好的配置文件去初始化Kubernetes集群了。这里直接使用kubeadm init命令去初始化即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 初始化，如果出现err异常，按提示解决后，进行kubeadmin reset，然后重新init</span><br><span class="line">kubeadm init --config init-kubeadm.conf</span><br><span class="line"></span><br><span class="line"># 发生错误1：[kubelet-check] The HTTP call equal to &#x27;curl -sSL http://localhost:10248/healthz&#x27; failed with error: Get &quot;http://localhost:10248/healthz&quot;: dial tcp [::1]:10248: connect: connection refused.</span><br><span class="line"></span><br><span class="line"># 解决办法：检查docker info|grep &quot;Cgroup Driver&quot;，如果是cgroupfs，修改docker配置/etc/docker/daemon.json添加&quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]。保持跟/var/lib/kubelet/config.yaml中cgroupDriver: systemd配置一致。</span><br><span class="line"></span><br><span class="line"># 发生错误2：/proc/sys/net/bridge/bridge-nf-call-iptables contents are not set to 1</span><br><span class="line"></span><br><span class="line"># 解决办法：echo &quot;1&quot; &gt; /proc/sys/net/bridge/bridge-nf-call-iptables，原因https://zhuanlan.zhihu.com/p/374919190。</span><br><span class="line"></span><br><span class="line"># 显示以下内容为成功</span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join 192.168.31.207:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:711c823eda08e200770830a2854703902a53bae00e92b7e4c4120ad24de22cXX </span><br></pre></td></tr></table></figure>

<p>上面的提示需要执行的内容为，作用为将默认的Kubernetes认证文件拷贝进.kube文件夹内，才能默认使用该配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p>前面我们在配置文件中，有提到过配置Pod子网络，Flannel主要的作用就是如此。它的主要作用是通过创建一个虚拟网络，让不同节点下的服务有着全局唯一的IP地址，且服务之前可以互相访问和连接。那么Flannel作为Kubernetes的一个组件，则使用Kubernetes部署服务的方式进行安装。首先下载配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 无法拉取就去https://ipaddress.com/website/raw.githubusercontent.com这个网站获取到ip，映射到本机hosts。</span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>我拉到了kube-flannel.yml组件配置文件，我们在配置文件中找到使用的镜像，initContainers下的install-cni下的镜像地址，我的是：rancher/mirrored-flannelcni-flannel:v0.16.3，接下来我们手动pull拉下来镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 配置段落</span><br><span class="line">- name: install-cni</span><br><span class="line">       #image: flannelcni/flannel:v0.16.3 for ppc64le and mips64le (dockerhub limitations may apply)</span><br><span class="line">        image: rancher/mirrored-flannelcni-flannel:v0.16.3</span><br><span class="line">        command:</span><br><span class="line">        - cp</span><br><span class="line">        args:</span><br><span class="line">        - -f</span><br><span class="line">        - /etc/kube-flannel/cni-conf.json</span><br><span class="line">        - /etc/cni/net.d/10-flannel.conflist</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: cni</span><br><span class="line">          mountPath: /etc/cni/net.d</span><br><span class="line">        - name: flannel-cfg</span><br><span class="line">          mountPath: /etc/kube-flannel/</span><br><span class="line"># 拉取镜像</span><br><span class="line">docker pull rancher/mirrored-flannelcni-flannel:v0.16.3</span><br></pre></td></tr></table></figure>

<p>等待镜像拉取结束后，可以使用kubectl apply命令加载下服务，在大约稍后1分钟左右，我们可以使用kubectl get nodes命令查看节点的运行状态。如果STATUS = ready，则代表启动成功。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 加载服务</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]# kubectl get nodes</span><br><span class="line">NAME   STATUS   ROLES                  AGE   VERSION</span><br><span class="line">node   Ready    control-plane,master   14m   v1.23.4</span><br></pre></td></tr></table></figure>

<h3 id="子节点安装"><a href="#子节点安装" class="headerlink" title="子节点安装"></a>子节点安装</h3><p>以下操作在两个子节点都进行操作。先将主节点的配置文件拷贝到两个子节点上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp $HOME/.kube/config root@子节点IP:~/</span><br></pre></td></tr></table></figure>

<p>归档子节点配置文件，执行下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo mv $HOME/config $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p>我们直接使用刚才在master生成的节点加入命令，在node机器上执行。让Node节点加入到master集群内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.31.207:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:711c823eda08e200770830a2854703902a53bae00e92b7e4c4120ad24de22c00</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 出现此段内容即成功</span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure>

<p>同上面主节点一样，安装flannel插件。</p>
<h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><h3 id="主节点配置部署文件"><a href="#主节点配置部署文件" class="headerlink" title="主节点配置部署文件"></a>主节点配置部署文件</h3><p>新建一个文件夹，名称叫 deployment，并在文件夹内创建一份 yaml 文件，名称为 v1，接着在配置文件中，写入以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mkdir deployment &amp;&amp; cd deployment</span><br><span class="line">vim v1.yaml</span><br><span class="line"></span><br><span class="line"># 当前资源配置</span><br><span class="line"></span><br><span class="line"># API配置版本</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line"># 资源类型</span><br><span class="line">kind: Deployment</span><br><span class="line"># 资源名称</span><br><span class="line">metadata:</span><br><span class="line">  name: front-v1</span><br><span class="line">  </span><br><span class="line"># 声明一个 Pod 组</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-v1</span><br><span class="line">  # 要创建的Pod最大数量,数字类型</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      # Pod组的名称</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-v1</span><br><span class="line">    # 组内创建的Pod信息</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      # Pod名称</span><br><span class="line">      - name: nginx</span><br><span class="line">        # 以什么镜像创建Pod。这里是Docker镜像地址</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/janlay/k8s_test:v1</span><br><span class="line">        ports:</span><br><span class="line">        # Pod内容器映射的端口</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></table></figure>

<p>我们使用kubectl apply来执行一份k8s的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动服务，-f等于--filename</span><br><span class="line">kubectl apply -f ./v1.yaml</span><br></pre></td></tr></table></figure>

<p>deployment并不会对pod进行网络通信和分发。想访问服务，有以下两个办法：</p>
<ul>
<li>直接访问具体的 Pod：这是一个办法，但是 Pod 太多了，达不到我们自动调度的效果。且 Pod 的 IP 在运行时还会经常进行漂移且不固定（后面会讲到）。</li>
<li>使用 Service  组织统一的 Pod 访问入口。</li>
</ul>
<p>Service的作用：流量会首先进入VM（主机），随后进入Service中，接着Service再去将流量调度给匹配的Pod。我们在v1.yaml里在追加service的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: front-service-v1</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-v1</span><br><span class="line">  ports:</span><br><span class="line">  # 通信类型（TCP/UDP）</span><br><span class="line">  - protocol: TCP</span><br><span class="line">    # k8s容器之间互相访问的端口</span><br><span class="line">    port: 80</span><br><span class="line">    # 原本Pod开放的端口</span><br><span class="line">    targetPort: 80</span><br><span class="line">  # NodePort，Service的一种访问方式</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure>

<p>修改完成后保存，我们再起启动服务，在部署成功Service后，我们可以使用kubectl get svc来获取我们已经部署的Service列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 启动服务</span><br><span class="line">kubectl apply -f ./v1.yaml</span><br><span class="line"># 获取服务列表</span><br><span class="line">kubectl get svc</span><br><span class="line"># 服务列表</span><br><span class="line">[root@k8s-master deployment]# kubectl get svc</span><br><span class="line">NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">front-service-v1   NodePort    10.97.200.131   &lt;none&gt;        80:31927/TCP   11s</span><br><span class="line">kubernetes         ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP        17h</span><br></pre></td></tr></table></figure>

<h3 id="ingress安装"><a href="#ingress安装" class="headerlink" title="ingress安装"></a>ingress安装</h3><p>在前面，我们部署了deployment和Service，实现了对服务的访问。但是在实际使用中，我们还会根据请求路径前缀的匹配，权重，甚至根据cookie/header的值去访问不同的服务。为了达到这种负载均衡的效果，我们可以使用k8s的另一个组件——ingress</p>
<p>在日常开发中，我们经常会遇到路径分流问题。例如当我们访问/a时，需要返回A服务的页面。访问/b，需要返回服务B的页面。这时候，我们就可以使用k8s中的ingress去实现。</p>
<p>在这里，我们选择ingress-nginx。ingress-nginx是基于nginx的一个ingress实现。当然也可以实现正则匹配路径，流量转发，基于cookieheader切分流量（灰度发布）。</p>
<p>下载ingress配置文件，然后修改deploy.yaml，NodePort字段为31234，https为31235，然后启动服务使ingress生效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 下载配置文件</span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/baremetal/deploy.yaml</span><br><span class="line"></span><br><span class="line"># 修改配置文件</span><br><span class="line">vim ./deploy.yaml</span><br><span class="line"></span><br><span class="line"># 修改信息</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ipFamilyPolicy: SingleStack</span><br><span class="line">  ipFamilies:</span><br><span class="line">    - IPv4</span><br><span class="line">  ports:</span><br><span class="line">    - name: http</span><br><span class="line">      port: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">      targetPort: http</span><br><span class="line">      appProtocol: http</span><br><span class="line">      nodePort: 31234</span><br><span class="line">    - name: https</span><br><span class="line">      port: 443</span><br><span class="line">      protocol: TCP</span><br><span class="line">      targetPort: https</span><br><span class="line">      appProtocol: https</span><br><span class="line">      nodePort: 31235</span><br><span class="line"># 启动服务</span><br><span class="line">kubectl apply -f deploy.yaml</span><br></pre></td></tr></table></figure>

<p>接下来会自动拉取ingress镜像，自动部署ingress。可以使用kubectl命令查看部署状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 以下两个命令都可以，-n为查看指定的命名空间</span><br><span class="line">kubectl get pods -n ingress-nginx -l app.kubernetes.io/name=ingress-nginx --watch</span><br><span class="line">kubectl -n ingress-nginx get svc</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]# kubectl -n ingress-nginx get svc</span><br><span class="line">NAME                                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)                           AGE</span><br><span class="line">ingress-nginx-controller             NodePort    10.97.41.136    &lt;none&gt;        31234:30952/TCP,31235:31359/TCP   87s</span><br><span class="line">ingress-nginx-controller-admission   ClusterIP   10.100.169.58   &lt;none&gt;        443/TCP                           87s</span><br></pre></td></tr></table></figure>

<p>接下来配置ingress，我们新建一个 <code>ingress</code> 文件夹，将 <code>ingress</code> 的配置放在里面并拷贝以下内容进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 创建配置文件目录和文件</span><br><span class="line">mkdir ingress &amp;&amp; cd ingress &amp;&amp; vim base.yaml</span><br><span class="line"></span><br><span class="line"># 拷贝内容</span><br><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-demo</span><br><span class="line">  annotations:</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /</span><br><span class="line">    kubernetes.io/ingress.class: nginx</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - http:</span><br><span class="line">      paths: </span><br><span class="line">       - path: /wss</span><br><span class="line">         pathType: Prefix</span><br><span class="line">         backend:</span><br><span class="line">           service:</span><br><span class="line">             name: front-service-v1</span><br><span class="line">             port:</span><br><span class="line">               number: 80</span><br></pre></td></tr></table></figure>

<p>配置主要分二部分：</p>
<ul>
<li>annotations是ingress的主要配置项目，可以用来修改这些配置来修改ingress的行为。我们可以通过修改这些配置来实现灰度发布，跨域资源，甚至将<a target="_blank" rel="noopener" href="http://www.abc.com重定向到abc.com./">www.abc.com重定向到abc.com。</a></li>
<li>rules是ingress配置路径转发规则的地方。path可以是一个路径字符串，也可以是一个正则表达式。backend则是k8s的service服务，serviceName是服务名称，servicePort是服务端口。当我们去访问/wss时，ingress就会帮我们调度到front-service-v1这个service上面。</li>
</ul>
<p>启动配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f ./base.yaml</span><br><span class="line"></span><br><span class="line"># 发生异常</span><br><span class="line">Error from server (InternalError): error when creating &quot;base.yaml&quot;: Internal error occurred: failed calling webhook &quot;validate.nginx.ingress.kubernetes.io&quot;: failed to call webhook: Post &quot;https://ingress-nginx-controller-admission.ingress-nginx.svc:443/networking/v1/ingresses?timeout=10s&quot;: dial tcp 10.98.70.75:443: connect: connection refused</span><br><span class="line"># 解决办法</span><br><span class="line">[root@k8s-master ingress]# kubectl get validatingwebhookconfigurations</span><br><span class="line">NAME                      WEBHOOKS   AGE</span><br><span class="line">ingress-nginx-admission   1          4m44s</span><br><span class="line">[root@k8s-master ingress]# kubectl delete -A ValidatingWebhookConfiguration ingress-nginx-admission</span><br><span class="line">validatingwebhookconfiguration.admissionregistration.k8s.io &quot;ingress-nginx-admission&quot; deleted</span><br></pre></td></tr></table></figure>

<h3 id="kubesphere安装"><a href="#kubesphere安装" class="headerlink" title="kubesphere安装"></a>kubesphere安装</h3><p><a target="_blank" rel="noopener" href="https://kubesphere.io/zh/docs/quick-start/all-in-one-on-linux/">https://kubesphere.io/zh/docs/quick-start/all-in-one-on-linux/</a></p>

        </div>
        
        <div class="post-tag">
            
            <a class="tag" href="/diary/tags/docker/" title="docker">docker</a>
            
            <a class="tag" href="/diary/tags/jenkins/" title="jenkins">jenkins</a>
            
            <a class="tag" href="/diary/tags/linux/" title="linux">linux</a>
            
        </div>
        
    </article>
</div>
<div class="paginator">
    
        
            <a class="prev" href="/diary/certbot%E5%88%9B%E5%BB%BAssl%E8%AF%81%E4%B9%A6.html">
                <i class="iconfont icon-prev"></i>
                <span class="nav-default">certbot创建ssl证书</span>
                <span class="nav-mobile">上一篇</span>
            </a>
        
        
            <a class="next" href="/diary/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html">
                <span class="nav-default">基于hexo搭建个人博客</span>
                <span class="nav-mobile">下一篇</span>
                <i class="iconfont icon-next"></i>
            </a>
        
    
</div>
<div id="comment-container"></div>
    </div>
</div>
<footer class="footer-social">
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
                2021 -
            
            2022
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/sanmiaohub">三喵</a>
        </p>
    </div>
</footer>
</body>

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">


<script src="/diary/js/index.js"></script>

<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>
    
    var gitalk = new Gitalk({
        clientID: 'ac5bcf4f0c99189ff836',
        clientSecret: '35001628275065c8216c7dac9cdff00ddcda1c88',
        repo: 'diary',
        owner: 'sanmiaohub',
        admin: ['sanmiaohub'],
        id: decodeURI(location.pathname),
        distractionFreeMode: false
    });

    gitalk.render('comment-container');
    

</script>
</html>
